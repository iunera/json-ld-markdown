<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Metadata Extractor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/js-yaml/4.1.0/js-yaml.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/json.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <style>
        .hljs {
            background: #1f2937 !important;
            border-radius: 0.5rem;
            padding: 1rem;
        }
        .fade-in {
            animation: fadeIn 0.3s ease-in;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .glass {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        textarea, input, select {
            transition: all 0.2s ease;
        }
        textarea:focus, input:focus, select:focus {
            transform: scale(1.01);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }
        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            display: inline-block;
            margin-left: 8px;
        }
        .status-success { background-color: #10b981; }
        .status-error { background-color: #ef4444; }
        .status-processing { background-color: #f59e0b; animation: pulse 1s infinite; }
    </style>
</head>
<body class="bg-gradient-to-br from-blue-50 to-indigo-100 min-h-screen">
    <!-- Header -->
    <header class="bg-gradient-to-r from-blue-600 to-indigo-700 text-white shadow-lg">
        <div class="container mx-auto px-6 py-4">
            <h1 class="text-3xl font-bold text-center">Enhanced Metadata Extractor</h1>
            <p class="text-center text-blue-100 mt-2">Transform Markdown to JSON-LD with Advanced Table & Annotation Support</p>
        </div>
    </header>

    <!-- Main Content -->
    <main class="container mx-auto px-6 py-8">
        <!-- Configuration Panel -->
        <div class="bg-white rounded-xl shadow-lg p-6 mb-8">
            <h2 class="text-xl font-semibold text-gray-800 mb-4 flex items-center">
                ‚öôÔ∏è Configuration
                <span id="configStatus" class="status-indicator status-success"></span>
            </h2>
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-6 gap-4">
                <div>
                    <label for="type" class="block text-sm font-medium text-gray-700 mb-2">Schema Type</label>
                    <select id="type" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                        <option value="Article" selected>Article</option>
                        <option value="NewsArticle">NewsArticle</option>
                        <option value="BlogPosting">BlogPosting</option>
                        <option value="TechArticle">TechArticle</option>
                        <option value="ScholarlyArticle">ScholarlyArticle</option>
                        <option value="HowTo">HowTo</option>
                        <option value="Report">Report</option>
                        <option value="SocialMediaPosting">SocialMediaPosting</option>
                        <option value="MedicalScholarlyArticle">MedicalScholarlyArticle</option>
                        <option value="SatiricalArticle">SatiricalArticle</option>
                        <option value="AdvertiserContentArticle">AdvertiserContentArticle</option>
                        <option value="WebPage">WebPage</option>
                    </select>
                </div>
                <div>
                    <label for="author" class="block text-sm font-medium text-gray-700 mb-2">Authors</label>
                    <input type="text" id="author" placeholder="John Doe, Jane Smith" 
                           class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                </div>
                <div>
                    <label for="publisherName" class="block text-sm font-medium text-gray-700 mb-2">Publisher</label>
                    <input type="text" id="publisherName" placeholder="Your Organization" 
                           class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                </div>
                <div>
                    <label for="publisherUrl" class="block text-sm font-medium text-gray-700 mb-2">Publisher URL</label>
                    <input type="url" id="publisherUrl" placeholder="https://example.com" 
                           class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                </div>
                <div>
                    <label for="baseUrl" class="block text-sm font-medium text-gray-700 mb-2">Base URL</label>
                    <input type="url" id="baseUrl" placeholder="https://example.com/blog/" 
                           class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                </div>
                <div>
                    <label for="slug" class="block text-sm font-medium text-gray-700 mb-2">Article Slug</label>
                    <input type="text" id="slug" placeholder="my-article-title" 
                           class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                </div>
            </div>
            
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 mt-4">
                <div>
                    <label for="date" class="block text-sm font-medium text-gray-700 mb-2">Publication Date</label>
                    <input type="date" id="date" 
                           class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                </div>
                <div>
                    <label for="categories" class="block text-sm font-medium text-gray-700 mb-2">Categories</label>
                    <input type="text" id="categories" placeholder="Technology, AI, Innovation" 
                           class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                </div>
                <div>
                    <label for="descLength" class="block text-sm font-medium text-gray-700 mb-2">Description Length</label>
                    <input type="number" id="descLength" value="300" min="50" max="1000" 
                           class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                </div>
            </div>
        </div>

        <!-- Main Processing Area -->
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
            <!-- Input Panel -->
            <div class="bg-white rounded-xl shadow-lg overflow-hidden">
                <div class="bg-gray-50 px-6 py-4 border-b">
                    <h3 class="text-lg font-semibold text-gray-800 flex items-center">
                        üìù Markdown Input
                        <span id="inputStatus" class="status-indicator status-success"></span>
                    </h3>
                    <p class="text-sm text-gray-600 mt-1">Enter your markdown with YAML front matter and inline annotations, or use the sample buttons below</p>
                </div>
                <div class="p-6">
                    <textarea id="markdownInput" rows="25" 
                              class="w-full font-mono text-sm border border-gray-300 rounded-lg p-4 focus:ring-2 focus:ring-blue-500 focus:border-transparent resize-none"
                              placeholder="Enter your markdown content here..."></textarea>
                    <div class="mt-4 flex items-center justify-between">
                        <div class="flex gap-2">
                            <button id="loadSample" class="px-4 py-2 bg-gray-100 text-gray-700 rounded-lg hover:bg-gray-200 transition-colors">
                                Article Sample
                            </button>
                            <button id="loadHowToSample" class="px-4 py-2 bg-blue-100 text-blue-700 rounded-lg hover:bg-blue-200 transition-colors">
                                HowTo Sample
                            </button>
                            <button id="loadTableSample" class="px-4 py-2 bg-green-100 text-green-700 rounded-lg hover:bg-green-200 transition-colors">
                                Table Sample
                            </button>
                        </div>
                        <div class="text-sm text-gray-500">
                            <span id="charCount">0</span> characters
                        </div>
                    </div>
                </div>
            </div>

            <!-- Output Panel -->
            <div class="bg-white rounded-xl shadow-lg overflow-hidden">
                <div class="bg-gray-50 px-6 py-4 border-b">
                    <h3 class="text-lg font-semibold text-gray-800 flex items-center justify-between">
                        <span class="flex items-center">
                            üîó JSON-LD Output
                            <span id="outputStatus" class="status-indicator status-success"></span>
                        </span>
                        <div class="flex gap-2">
                            <button id="formatButton" class="px-3 py-1 text-xs bg-blue-100 text-blue-700 rounded hover:bg-blue-200 transition-colors">
                                Format
                            </button>
                            <button id="copyButton" class="px-3 py-1 text-xs bg-green-100 text-green-700 rounded hover:bg-green-200 transition-colors">
                                Copy
                            </button>
                        </div>
                    </h3>
                    <p class="text-sm text-gray-600 mt-1">Generated structured data in JSON-LD format</p>
                </div>
                <div class="p-6">
                    <div class="bg-gray-900 rounded-lg overflow-hidden">
                        <pre><code id="output" class="language-json text-sm"></code></pre>
                    </div>
                    <div class="mt-4 text-sm text-gray-500" id="outputInfo">
                        Ready to generate JSON-LD
                    </div>
                </div>
            </div>
        </div>

        <!-- Statistics Panel -->
        <div class="mt-8 bg-white rounded-xl shadow-lg p-6">
            <h3 class="text-lg font-semibold text-gray-800 mb-4">üìä Processing Statistics</h3>
            <div class="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-6 gap-4">
                <div class="bg-blue-50 rounded-lg p-4 text-center">
                    <div class="text-2xl font-bold text-blue-600" id="annotationCount">0</div>
                    <div class="text-sm text-gray-600">Annotations</div>
                </div>
                <div class="bg-green-50 rounded-lg p-4 text-center">
                    <div class="text-2xl font-bold text-green-600" id="faqCount">0</div>
                    <div class="text-sm text-gray-600">FAQ Items</div>
                </div>
                <div class="bg-purple-50 rounded-lg p-4 text-center">
                    <div class="text-2xl font-bold text-purple-600" id="sectionCount">0</div>
                    <div class="text-sm text-gray-600">Sections</div>
                </div>
                <div class="bg-orange-50 rounded-lg p-4 text-center">
                    <div class="text-2xl font-bold text-orange-600" id="tableCount">0</div>
                    <div class="text-sm text-gray-600">Tables</div>
                </div>
                <div class="bg-pink-50 rounded-lg p-4 text-center">
                    <div class="text-2xl font-bold text-pink-600" id="listCount">0</div>
                    <div class="text-sm text-gray-600">Lists</div>
                </div>
                <div class="bg-indigo-50 rounded-lg p-4 text-center">
                    <div class="text-2xl font-bold text-indigo-600" id="entityCount">0</div>
                    <div class="text-sm text-gray-600">Total Entities</div>
                </div>
            </div>
        </div>
    </main>

    <!-- Footer -->
    <footer class="bg-gray-800 text-white py-8 mt-12">
        <div class="container mx-auto px-6 text-center">
            <p class="text-gray-300">Enhanced Metadata Extractor - Transform your content into structured data</p>
            <p class="text-gray-400 text-sm mt-2">Enter markdown content or click sample buttons to get started. YAML metadata auto-populates form fields.</p>
        </div>
    </footer>

    <script>
        // Configuration Management
        class Config {
            static DEFAULT_TYPE = 'Article';
            static DEFAULT_SCHEMA = 'https://schema.org';
            static DEFAULT_BASE_URL = 'https://www.iunera.com/blog/';
            static DEFAULT_DATE = '2025-06-01';
            static DEFAULT_AUTHOR = ['Christian Schmitt', 'Dr. Tim Frey'];
            static DEFAULT_PUBLISHER = { 
                '@type': 'Organization', 
                name: 'Iunera', 
                '@id': 'https://www.iunera.com',
                url: 'https://www.iunera.com/',
                address: {
                    '@type': 'PostalAddress',
                    streetAddress: 'Altrottstra√üe 31',
                    addressLocality: 'Walldorf',
                    postalCode: '69190'
                },
                telephone: '+49 6227 381350'
            };
            static DEFAULT_SLUG = 'license-token-fair-code';
            static DEFAULT_KEYWORDS = ['open source', 'fair code', 'license token', 'blockchain', 'AI'];
            static DEFAULT_CATEGORIES = ['Technology', 'Software Licensing', 'Blockchain Innovation'];
            static DEFAULT_DESCRIPTION_LENGTH = 300;

            constructor(options = {}) {
                this.type = options.type || Config.DEFAULT_TYPE;
                this.schema = options.schema || Config.DEFAULT_SCHEMA;
                this.baseUrl = options.baseUrl || Config.DEFAULT_BASE_URL;
                this.date = options.date || Config.DEFAULT_DATE;
                this.author = options.author || [...Config.DEFAULT_AUTHOR];
                this.publisher = options.publisher || {...Config.DEFAULT_PUBLISHER};
                this.slug = options.slug || Config.DEFAULT_SLUG;
                this.keywords = options.keywords || [...Config.DEFAULT_KEYWORDS];
                this.categories = options.categories || [...Config.DEFAULT_CATEGORIES];
                this.descriptionLength = options.descriptionLength || Config.DEFAULT_DESCRIPTION_LENGTH;
            }
        }

        // Enhanced Markdown Parser
        class EnhancedMarkdownParser {
            extractMetadata(content) {
                const frontMatterMatch = content.match(/^---\n([\s\S]*?)\n---\n/);
                if (!frontMatterMatch) return {};

                try {
                    const yamlContent = frontMatterMatch[1].trim();
                    const metadata = jsyaml.load(yamlContent) || {};
                    return metadata;
                } catch (error) {
                    console.error('YAML parsing error:', error);
                    return {};
                }
            }

            extractContext(content) {
                const contextMatch = content.match(/^@context:\s*(https?:\/\/[^\s]+)$/m);
                return contextMatch ? contextMatch[1] : 'https://schema.org';
            }

            extractTables(content) {
                const tables = [];
                const cleanContent = this.removeYamlAndContext(content);
                const lines = cleanContent.split('\n');
                
                let currentTable = null;
                let headers = [];
                let tableData = [];
                
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();
                    
                    if (line.match(/^\|.*\|$/)) {
                        const cells = line.split('|').slice(1, -1).map(cell => cell.trim());
                        
                        if (!currentTable) {
                            headers = cells.map(cell => this.cleanText(cell));
                            currentTable = {
                                '@type': 'Table',
                                name: `Table ${tables.length + 1}`,
                                description: `Data table with columns: ${headers.join(', ')}`
                            };
                        } else {
                            if (!cells.every(cell => cell.match(/^[-:\s]*$/))) {
                                const cleanCells = cells.map(cell => this.cleanText(cell));
                                if (cleanCells.some(cell => cell.length > 0)) {
                                    tableData.push(cleanCells);
                                }
                            }
                        }
                    } else if (line.match(/^\|[-:\s|]+\|$/)) {
                        continue;
                    } else if (currentTable && (headers.length > 0 || tableData.length > 0)) {
                        const processedTable = this.processTableToSchema(headers, tableData, tables.length + 1);
                        tables.push(processedTable);
                        currentTable = null;
                        headers = [];
                        tableData = [];
                    }
                }
                
                if (currentTable && (headers.length > 0 || tableData.length > 0)) {
                    const processedTable = this.processTableToSchema(headers, tableData, tables.length + 1);
                    tables.push(processedTable);
                }
                
                return tables;
            }

            processTableToSchema(headers, tableData, tableNumber) {
                const tableType = this.analyzeTableType(headers, tableData);
                
                const baseTable = {
                    '@type': tableType.type,
                    name: tableType.name || `Table ${tableNumber}`,
                    description: this.generateTableDescription(headers, tableData, tableType)
                };

                switch (tableType.category) {
                    case 'pricing':
                        return this.createPricingTable(baseTable, headers, tableData);
                    case 'comparison':
                        return this.createComparisonTable(baseTable, headers, tableData);
                    case 'specification':
                        return this.createSpecificationTable(baseTable, headers, tableData);
                    case 'listing':
                        return this.createListingTable(baseTable, headers, tableData);
                    case 'dataset':
                        return this.createDatasetTable(baseTable, headers, tableData);
                    default:
                        return this.createGenericTable(baseTable, headers, tableData);
                }
            }

            analyzeTableType(headers, tableData) {
                const headerText = headers.join(' ').toLowerCase();
                const allData = tableData.flat().join(' ').toLowerCase();
                
                if (headerText.match(/price|cost|plan|tier|subscription|fee|rate/) || 
                    allData.match(/\$|‚Ç¨|¬£|¬•|‚Çπ|\d+\.\d{2}|free|premium|basic|pro/)) {
                    return {
                        type: 'Table',
                        category: 'pricing',
                        name: 'Pricing Comparison Table'
                    };
                }
                
                if (headerText.match(/vs|versus|compare|feature|support|included|type|model/) ||
                    headers.length > 2 && tableData.some(row => 
                        row.some(cell => cell && cell.toString().toLowerCase().match(/yes|no|‚úì|‚úó|included|supported|available|none|limited|partial/)))) {
                    return {
                        type: 'Table', 
                        category: 'comparison',
                        name: 'Feature Comparison Table'
                    };
                }
                
                if (headerText.match(/spec|specification|property|attribute|parameter|value|requirement/) ||
                    headers.some(h => h.match(/spec|model|version|size|weight|dimension/))) {
                    return {
                        type: 'Table',
                        category: 'specification', 
                        name: 'Specifications Table'
                    };
                }
                
                if (headerText.match(/name|title|item|product|service|company|organization/) &&
                    tableData.length > 3) {
                    return {
                        type: 'Table',
                        category: 'listing',
                        name: 'Directory Listing Table'
                    };
                }
                
                if (headers.length > 3 && tableData.length > 5 &&
                    headers.some(h => h.match(/data|metric|value|count|number|amount/))) {
                    return {
                        type: 'Dataset',
                        category: 'dataset',
                        name: 'Data Table'
                    };
                }
                
                return {
                    type: 'Table',
                    category: 'generic',
                    name: `Data Table`
                };
            }

            generateTableDescription(headers, tableData, tableType) {
                const rowCount = tableData.length;
                const columnCount = headers.length;
                
                let description = `A ${tableType.category} table with ${columnCount} columns and ${rowCount} rows`;
                
                switch (tableType.category) {
                    case 'pricing':
                        description += ' containing pricing information and plan comparisons';
                        break;
                    case 'comparison':
                        description += ' comparing features and capabilities across different options';
                        break;
                    case 'specification':
                        description += ' listing technical specifications and properties';
                        break;
                    case 'listing':
                        description += ' providing a directory of items, companies, or resources';
                        break;
                    case 'dataset':
                        description += ' containing structured data for analysis';
                        break;
                    default:
                        description += ' with structured tabular data';
                }
                
                if (headers.length > 0) {
                    description += `. Columns: ${headers.slice(0, 3).join(', ')}`;
                    if (headers.length > 3) {
                        description += ` and ${headers.length - 3} more`;
                    }
                }
                
                return description + '.';
            }

            createPricingTable(baseTable, headers, tableData) {
                const priceColumnIndex = headers.findIndex(h => 
                    h.toLowerCase().match(/price|cost|fee|rate/));
                const nameColumnIndex = headers.findIndex(h => 
                    h.toLowerCase().match(/plan|tier|name|package/));
                
                baseTable.about = {
                    '@type': 'PriceSpecification',
                    description: 'Pricing information and plan comparisons'
                };
                
                let pricingText = 'Pricing table containing: ';
                if (tableData.length > 0) {
                    const priceDescriptions = tableData.map(row => {
                        const name = nameColumnIndex >= 0 ? row[nameColumnIndex] : 'Plan';
                        const price = priceColumnIndex >= 0 ? row[priceColumnIndex] : 'Price not specified';
                        return `${name}: ${price}`;
                    });
                    pricingText += priceDescriptions.join(', ');
                }
                
                baseTable.text = pricingText;
                return baseTable;
            }

            createComparisonTable(baseTable, headers, tableData) {
                baseTable['@type'] = 'Table';
                baseTable.about = {
                    '@type': 'Thing',
                    name: 'Feature Comparison',
                    description: 'Comparison of features, capabilities, or characteristics'
                };
                
                let comparisonText = '';
                if (headers.length > 0) {
                    comparisonText = `Comparison table with columns: ${headers.join(', ')}. `;
                }
                
                if (tableData.length > 0) {
                    const summaryRows = tableData.slice(0, 3).map(row => {
                        return headers.map((header, index) => 
                            `${header}: ${row[index] || 'N/A'}`
                        ).join(', ');
                    });
                    comparisonText += `Data includes: ${summaryRows.join('; ')}.`;
                    if (tableData.length > 3) {
                        comparisonText += ` (${tableData.length - 3} more rows)`;
                    }
                }
                
                baseTable.text = comparisonText.trim();
                
                return baseTable;
            }

            createSpecificationTable(baseTable, headers, tableData) {
                baseTable.about = {
                    '@type': 'Product',
                    description: 'Technical specifications and properties'
                };
                
                const propertyColumn = headers.findIndex(h => 
                    h.toLowerCase().match(/property|spec|feature|attribute/));
                const valueColumn = headers.findIndex(h => 
                    h.toLowerCase().match(/value|specification|detail/));
                
                let specText = 'Specification table with properties: ';
                if (tableData.length > 0) {
                    const specDescriptions = tableData.slice(0, 5).map(row => {
                        const prop = propertyColumn >= 0 ? row[propertyColumn] : `Property ${tableData.indexOf(row) + 1}`;
                        const val = valueColumn >= 0 ? row[valueColumn] : 'Value not specified';
                        return `${prop}: ${val}`;
                    });
                    specText += specDescriptions.join(', ');
                    if (tableData.length > 5) {
                        specText += ` and ${tableData.length - 5} more specifications`;
                    }
                }
                
                baseTable.text = specText;
                return baseTable;
            }

            createListingTable(baseTable, headers, tableData) {
                const nameColumn = headers.findIndex(h => 
                    h.toLowerCase().match(/name|title|company|organization|item/));
                const urlColumn = headers.findIndex(h => 
                    h.toLowerCase().match(/url|website|link/));
                
                let listingText = 'Directory listing with entries: ';
                if (tableData.length > 0) {
                    const listingDescriptions = tableData.slice(0, 3).map(row => {
                        const name = nameColumn >= 0 ? row[nameColumn] : `Item ${tableData.indexOf(row) + 1}`;
                        let url = '';
                        if (urlColumn >= 0 && row[urlColumn]) {
                            const urlValue = row[urlColumn];
                            if (urlValue.startsWith('http') && 
                                !urlValue.includes('example.com') &&
                                !urlValue.includes('docs.octl.org') &&
                                !urlValue.match(/\.(test|invalid|local)($|\/)/)) {
                                url = ` (${urlValue})`;
                            }
                        }
                        return name + url;
                    });
                    listingText += listingDescriptions.join(', ');
                    if (tableData.length > 3) {
                        listingText += ` and ${tableData.length - 3} more items`;
                    }
                }
                
                baseTable.text = listingText;
                return baseTable;
            }

            createDatasetTable(baseTable, headers, tableData) {
                baseTable['@type'] = 'Dataset';
                baseTable.description = `Dataset with ${headers.length} variables and ${tableData.length} observations`;
                
                let datasetText = `Dataset containing ${tableData.length} rows of data with variables: ${headers.join(', ')}.`;
                
                const numericColumns = this.detectNumericColumns(headers, tableData);
                if (numericColumns.length > 0) {
                    datasetText += ` Includes ${numericColumns.length} numeric variables with statistical analysis available.`;
                }
                
                baseTable.text = datasetText;
                return baseTable;
            }

            createGenericTable(baseTable, headers, tableData) {
                return this.addTableStructure(baseTable, headers, tableData);
            }

            addTableStructure(table, headers, tableData) {
                let tableText = '';
                if (headers.length > 0) {
                    tableText = `Table headers: ${headers.join(', ')}. `;
                }
                
                if (tableData.length > 0) {
                    const rowTexts = tableData.slice(0, 3).map(row => {
                        return headers.map((header, index) => 
                            `${header}: ${row[index] || 'N/A'}`
                        ).join(', ');
                    });
                    tableText += `Sample data: ${rowTexts.join('; ')}.`;
                    if (tableData.length > 3) {
                        tableText += ` (${tableData.length - 3} more rows)`;
                    }
                }
                
                table.text = tableText.trim();
                
                table.description = table.description || `Data table with ${headers.length} columns and ${tableData.length} rows`;
                
                return table;
            }

            extractPrice(text) {
                const currencySymbols = { '$': 'USD', '‚Ç¨': 'EUR', '¬£': 'GBP', '¬•': 'JPY', '‚Çπ': 'INR' };
                const priceMatch = text.match(/([$‚Ç¨¬£¬•‚Çπ])\s*(\d+(?:\.\d{2})?)|(\d+(?:\.\d{2})?)\s*(USD|EUR|GBP|JPY|INR)/i);
                
                if (priceMatch) {
                    const symbol = priceMatch[1];
                    const amount = priceMatch[2] || priceMatch[3];
                    const currency = symbol ? currencySymbols[symbol] : priceMatch[4];
                    
                    return {
                        amount: parseFloat(amount),
                        currency: currency
                    };
                }
                
                return null;
            }

            detectNumericColumns(headers, tableData) {
                const numericColumns = [];
                
                headers.forEach((header, columnIndex) => {
                    const columnValues = tableData.map(row => row[columnIndex])
                        .filter(value => value && !isNaN(parseFloat(value)))
                        .map(value => parseFloat(value));
                    
                    if (columnValues.length > tableData.length * 0.5) {
                        numericColumns.push({
                            name: header,
                            index: columnIndex,
                            count: columnValues.length,
                            min: Math.min(...columnValues),
                            max: Math.max(...columnValues),
                            average: columnValues.reduce((a, b) => a + b, 0) / columnValues.length
                        });
                    }
                });
                
                return numericColumns;
            }

            extractLists(content) {
                const lists = [];
                const cleanContent = this.removeYamlAndContext(content);
                const lines = cleanContent.split('\n');
                
                let currentList = null;
                let listItems = [];
                let listType = null;
                
                for (const line of lines) {
                    const trimmed = line.trim();
                    
                    const unorderedMatch = trimmed.match(/^[-*+]\s+(.+)$/);
                    const orderedMatch = trimmed.match(/^\d+\.\s+(.+)$/);
                    
                    if (unorderedMatch || orderedMatch) {
                        const itemText = unorderedMatch ? unorderedMatch[1] : orderedMatch[1];
                        const currentListType = unorderedMatch ? 'unordered' : 'ordered';
                        
                        if (!currentList || listType !== currentListType) {
                            if (currentList && listItems.length > 0) {
                                currentList.itemListElement = listItems;
                                currentList.numberOfItems = listItems.length;
                                lists.push(currentList);
                            }
                            
                            currentList = {
                                '@type': 'ItemList',
                                name: `${unorderedMatch ? 'Bulleted' : 'Numbered'} List ${lists.length + 1}`,
                                description: `A ${unorderedMatch ? 'bulleted' : 'numbered'} list of items`
                            };
                            listItems = [];
                            listType = currentListType;
                        }
                        
                        listItems.push({
                            '@type': 'ListItem',
                            name: this.cleanText(itemText),
                            position: listItems.length + 1
                        });
                    } else if (currentList && trimmed === '') {
                        continue;
                    } else if (currentList && !trimmed.match(/^#/) && trimmed) {
                        if (listItems.length > 0) {
                            currentList.itemListElement = listItems;
                            currentList.numberOfItems = listItems.length;
                            lists.push(currentList);
                            currentList = null;
                            listItems = [];
                            listType = null;
                        }
                    }
                }
                
                if (currentList && listItems.length > 0) {
                    currentList.itemListElement = listItems;
                    currentList.numberOfItems = listItems.length;
                    lists.push(currentList);
                }
                
                return lists;
            }

            extractLinks(content, articleUrl = null) {
                const links = [];
                const linkRegex = /\[([^\]]+)\]\(([^)]+)\)(?!@\{)/g;
                let match;
                
                while ((match = linkRegex.exec(content)) !== null) {
                    const [, linkText, url] = match;
                    
                    if (!url.startsWith('http')) {
                        continue;
                    }
                    
                    let linkType = 'WebPage';
                    if (url.includes('github.com')) linkType = 'SoftwareSourceCode';
                    else if (url.includes('youtube.com') || url.includes('youtu.be')) linkType = 'VideoObject';
                    else if (url.match(/\.(pdf|doc|docx)$/i)) linkType = 'DigitalDocument';
                    else if (url.match(/\.(jpg|jpeg|png|gif|svg)$/i)) linkType = 'ImageObject';
                    
                    links.push({
                        '@type': linkType,
                        name: this.cleanText(linkText),
                        url: url,
                        '@id': url
                    });
                }
                
                return links;
            }

            extractAnnotations(content) {
                const annotations = [];
                const annotationRegex = /\[([^\]]*?)\](?:\(([^)]+)\))?@\{([^}]+)\}/g;
                let match;

                while ((match = annotationRegex.exec(content)) !== null) {
                    const [, text, url, annotationContent] = match;
                    const annotation = this.parseAnnotation(text, url, annotationContent);
                    if (annotation) {
                        annotations.push(annotation);
                    }
                }

                return annotations;
            }

            parseAnnotation(text, url, annotationContent) {
                const parts = annotationContent.split(',').map(part => part.trim());
                const type = parts[0];
                const properties = { '@type': type };

                for (let i = 1; i < parts.length; i++) {
                    const [key, value] = parts[i].split('=').map(s => s.trim());
                    if (key && value) {
                        if (key === '@id') {
                            properties['@id'] = value;
                        } else if (key.includes('.')) {
                            const [parent, child] = key.split('.');
                            properties[parent] = properties[parent] || {};
                            if (parent === 'publisher' && child === 'name') {
                                properties[parent][child] = value;
                            } else {
                                properties[parent][child] = this.processValue(value);
                            }
                        } else {
                            properties[key] = this.processValue(value);
                        }
                    }
                }

                if (!properties.name && text) {
                    properties.name = text;
                }

                if (url) {
                    properties.url = url;
                }

                if (type === 'Person' && text && !properties.givenName) {
                    properties.givenName = text;
                }

                if (properties.license && typeof properties.license === 'string') {
                    if (properties.license.startsWith('http')) {
                        properties.license = { '@id': properties.license };
                    }
                }

                return {
                    '@context': 'https://schema.org',
                    ...properties
                };
            }

            processValue(value) {
                if (value.match(/^https?:\/\//)) {
                    return value;
                }
                if (value.startsWith('#')) {
                    return value;
                }
                return value;
            }

            extractTitle(content) {
                const cleanContent = this.removeYamlAndContext(content);
                const titleMatch = cleanContent.match(/^#\s+(.+)$/m);
                return titleMatch ? this.cleanText(titleMatch[1]) : null;
            }

            extractDescription(content, maxLength) {
                const cleanContent = this.removeYamlAndContext(content);
                const lines = cleanContent.split('\n');
                
                for (const line of lines) {
                    const trimmed = line.trim();
                    if (trimmed && 
                        !trimmed.match(/^#+\s/) && 
                        !trimmed.match(/^\|.*\|$/) && 
                        !trimmed.match(/^\|[-:\s|]+\|$/) && 
                        !trimmed.match(/^[-*+]\s/) && 
                        !trimmed.match(/^\d+\.\s/) && 
                        !trimmed.match(/^\[.*\]@\{/)) { 
                        
                        const cleaned = this.cleanText(trimmed);
                        if (cleaned.length > 0) {
                            return cleaned.slice(0, maxLength);
                        }
                    }
                }
                return null;
            }

            extractArticleBody(content) {
                const cleanContent = this.removeYamlAndContext(content);
                const finalContent = this.cleanText(cleanContent);
                
                const result = finalContent.split('\n')
                    .map(line => line.trim())
                    .filter(line => line && !line.includes('--- end of article'))
                    .join(' ');
                    
                return result;
            }

            extractSections(content) {
                const sections = [];
                const cleanContent = this.removeYamlAndContext(content);
                const lines = cleanContent.split('\n');
                
                let currentSection = null;
                let currentContent = [];
                
                for (const line of lines) {
                    const trimmed = line.trim();
                    
                    if (trimmed.includes('--- end of article')) {
                        continue;
                    }
                    
                    const headingMatch = trimmed.match(/^(#{2,})\s+(.+)$/);
                    
                    if (headingMatch) {
                        const headingText = headingMatch[2];
                        
                        if (currentSection && currentContent.length > 0) {
                            const sectionText = this.cleanText(currentContent.join('\n').trim());
                            if (sectionText) {
                                sections.push({
                                    '@type': 'WebPageElement',
                                    name: this.cleanText(currentSection),
                                    text: sectionText,
                                    cssSelector: `#${this.cleanText(currentSection).toLowerCase().replace(/\s+/g, '-').replace(/[^\w-]/g, '')}`,
                                    position: sections.length + 1
                                });
                            }
                        }
                        
                        currentSection = headingText;
                        currentContent = [];
                    } else if (currentSection && trimmed) {
                        currentContent.push(trimmed);
                    }
                }
                
                if (currentSection && currentContent.length > 0) {
                    const sectionText = this.cleanText(currentContent.join('\n').trim());
                    if (sectionText) {
                        sections.push({
                            '@type': 'WebPageElement',
                            name: this.cleanText(currentSection),
                            text: sectionText,
                            cssSelector: `#${this.cleanText(currentSection).toLowerCase().replace(/\s+/g, '-').replace(/[^\w-]/g, '')}`,
                            position: sections.length + 1
                        });
                    }
                }
                
                return sections;
            }

            extractFaqQuestions(content) {
                const faqQuestions = [];
                const cleanContent = this.removeYamlAndContext(content);
                const lines = cleanContent.split('\n');
                
                let inFaqSection = false;
                let currentQuestion = null;
                let currentAnswer = [];

                for (const line of lines) {
                    if (line.match(/^##\s+(FAQ|Frequently Asked Questions)/i)) {
                        inFaqSection = true;
                        continue;
                    }
                    
                    if (inFaqSection && line.match(/^###\s+/)) {
                        if (currentQuestion && currentAnswer.length) {
                            faqQuestions.push({
                                '@type': 'Question',
                                name: this.cleanText(currentQuestion),
                                acceptedAnswer: {
                                    '@type': 'Answer',
                                    text: this.cleanText(currentAnswer.join(' ').trim())
                                }
                            });
                        }
                        currentQuestion = line.replace(/^###\s+/, '').trim();
                        currentAnswer = [];
                    } else if (inFaqSection && currentQuestion && line.trim() && !line.includes('--- end of article')) {
                        currentAnswer.push(line.trim());
                    }
                }

                if (currentQuestion && currentAnswer.length) {
                    faqQuestions.push({
                        '@type': 'Question',
                        name: this.cleanText(currentQuestion),
                        acceptedAnswer: {
                            '@type': 'Answer',
                            text: this.cleanText(currentAnswer.join(' ').trim())
                        }
                    });
                }

                return faqQuestions;
            }

            removeYamlAndContext(content) {
                let cleaned = content.replace(/^@context:\s*https?:\/\/[^\n]+\n\n?/m, '');
                cleaned = cleaned.replace(/^---\n[\s\S]*?\n---\n/, '');
                return cleaned;
            }

            cleanText(text) {
                let cleaned = text;
                
                cleaned = cleaned.replace(/\*\*\*([^*]+)\*\*\*/g, '$1');
                cleaned = cleaned.replace(/\*\*([^*]+)\*\*/g, '$1');
                cleaned = cleaned.replace(/\*([^*]+)\*/g, '$1');
                cleaned = cleaned.replace(/___([^_]+)___/g, '$1');
                cleaned = cleaned.replace(/__([^_]+)__/g, '$1');
                cleaned = cleaned.replace(/_([^_]+)_/g, '$1');
                cleaned = cleaned.replace(/`([^`]+)`/g, '$1');
                cleaned = cleaned.replace(/```[\s\S]*?```/g, (match) => {
                    return match.replace(/```[\w]*\n?/g, '').replace(/```/g, '');
                });
                cleaned = cleaned.replace(/~~([^~]+)~~/g, '$1');
                cleaned = cleaned.replace(/\[([^\]]+)\]\([^)]+\)(?!@\{)/g, '$1');
                cleaned = cleaned.replace(/\[([^\]]*?)\](?:\(([^)]+)\))?@\{([^}]+)\}/g, '$1');
                cleaned = cleaned.replace(/^#+\s*/gm, '');
                cleaned = cleaned.replace(/^\s*[-*+]\s+/gm, '');
                cleaned = cleaned.replace(/^\s*\d+\.\s+/gm, '');
                cleaned = cleaned.replace(/^\s*>\s+/gm, '');
                cleaned = cleaned.replace(/\|([^|\n]*)\|/g, (match, content) => {
                    return content.split('|').map(cell => cell.trim()).join(' ');
                });
                cleaned = cleaned.replace(/\|/g, '');
                cleaned = cleaned.replace(/^\s*\|[-:\s|]+\|\s*$/gm, '');
                cleaned = cleaned.replace(/\n{3,}/g, '\n\n');
                cleaned = cleaned.replace(/[ \t]+/g, ' ');
                cleaned = cleaned.trim();
                
                return cleaned;
            }
        }

        // JSON-LD Transformer
        class JsonLDTransformer {
            static transform(markdownContent, config) {
                const parser = new EnhancedMarkdownParser();
                const context = parser.extractContext(markdownContent);
                
                const articleUrl = `${config.baseUrl.replace(/\/$/, '')}/${config.slug}`;
                
                const annotations = parser.extractAnnotations(markdownContent);
                const title = parser.extractTitle(markdownContent);
                const description = parser.extractDescription(markdownContent, config.descriptionLength);
                const articleBody = parser.extractArticleBody(markdownContent);
                const faqQuestions = parser.extractFaqQuestions(markdownContent);
                const sections = parser.extractSections(markdownContent);
                const tables = parser.extractTables(markdownContent);
                const lists = parser.extractLists(markdownContent);
                const links = parser.extractLinks(markdownContent, articleUrl);

                const isHowTo = config.type === 'HowTo' || 
                    (title && title.toLowerCase().includes('how to')) ||
                    (title && title.toLowerCase().startsWith('how '));

                const mainEntity = {
                    '@context': context,
                    '@type': isHowTo ? 'HowTo' : config.type,
                    name: title || 'Untitled Article',
                    description: description || articleBody.slice(0, config.descriptionLength),
                    datePublished: config.date,
                    author: this.processAuthors(config.author, articleUrl),
                    publisher: this.processPublisher(config.publisher),
                    keywords: config.keywords,
                    about: config.categories.map(c => ({
                        '@type': 'Thing',
                        name: c
                    }))
                };

                if (isHowTo) {
                    if (sections.length > 0) {
                        mainEntity.step = sections.map((section, index) => ({
                            '@type': 'HowToStep',
                            name: section.name,
                            text: section.text,
                            position: index + 1,
                            url: `${articleUrl}#${section.cssSelector.replace('#', '')}`
                        }));
                    }
                    mainEntity.totalTime = 'PT30M';
                } else {
                    mainEntity.articleBody = articleBody;
                    mainEntity.url = articleUrl;
                    
                    const validParts = [];
                    
                    if (sections.length > 0) {
                        validParts.push(...sections);
                    }
                    
                    if (tables.length > 0) {
                        validParts.push(...tables);
                    }
                    
                    if (validParts.length > 0) {
                        mainEntity.hasPart = validParts;
                    }
                }

                if (links.length > 0) {
                    const realLinks = links.filter(link => link.url && link.url.startsWith('http'));
                    if (realLinks.length > 0) {
                        mainEntity.mentions = realLinks.map(link => ({
                            '@id': link.url
                        }));
                    }
                }

                const result = [mainEntity];

                if (faqQuestions.length > 0) {
                    result.push({
                        '@context': context,
                        '@type': 'FAQPage',
                        name: `FAQ: ${mainEntity.name}`,
                        mainEntity: faqQuestions,
                        mainEntityOfPage: {
                            '@type': 'WebPage',
                            '@id': articleUrl
                        },
                        datePublished: mainEntity.datePublished,
                        author: mainEntity.author,
                        publisher: mainEntity.publisher
                    });
                }

                lists.forEach(list => {
                    list['@context'] = context;
                    result.push(list);
                });

                links.forEach(link => {
                    link['@context'] = context;
                    if (link.url && link.url.startsWith('http')) {
                        result.push(link);
                    }
                });

                annotations.forEach((annotation, index) => {
                    annotation['@context'] = context;
                    
                    if (annotation['@id'] && !annotation['@id'].startsWith('http')) {
                        delete annotation['@id'];
                    }
                    
                    result.push(annotation);
                });

                return result;
            }

            static processAuthors(authors, articleUrl) {
                return authors.map(author => ({
                    '@type': 'Person',
                    name: author
                }));
            }

            static processPublisher(publisher) {
                return {
                    '@type': 'Organization',
                    ...publisher
                };
            }
        }

        // UI Controller
        class UIController {
            constructor() {
                this.initializeElements();
                this.setupEventListeners();
                this.setDefaultDate();
                this.updateTransformation();
            }

            setDefaultDate() {
                const today = new Date().toISOString().split('T')[0];
                this.dateInput.value = today;
            }

            initializeElements() {
                this.markdownInput = document.getElementById('markdownInput');
                this.output = document.getElementById('output');
                this.typeInput = document.getElementById('type');
                this.authorInput = document.getElementById('author');
                this.publisherNameInput = document.getElementById('publisherName');
                this.publisherUrlInput = document.getElementById('publisherUrl');
                this.baseUrlInput = document.getElementById('baseUrl');
                this.slugInput = document.getElementById('slug');
                this.dateInput = document.getElementById('date');
                this.categoriesInput = document.getElementById('categories');
                this.descLengthInput = document.getElementById('descLength');
                this.copyButton = document.getElementById('copyButton');
                this.formatButton = document.getElementById('formatButton');
                this.loadSampleButton = document.getElementById('loadSample');
                this.loadHowToSampleButton = document.getElementById('loadHowToSample');
                this.loadTableSampleButton = document.getElementById('loadTableSample');
                this.charCount = document.getElementById('charCount');
                this.outputInfo = document.getElementById('outputInfo');
                
                this.annotationCount = document.getElementById('annotationCount');
                this.faqCount = document.getElementById('faqCount');
                this.sectionCount = document.getElementById('sectionCount');
                this.entityCount = document.getElementById('entityCount');
                
                this.inputStatus = document.getElementById('inputStatus');
                this.outputStatus = document.getElementById('outputStatus');
            }

            setupEventListeners() {
                const debounce = (func, wait) => {
                    let timeout;
                    return (...args) => {
                        clearTimeout(timeout);
                        timeout = setTimeout(() => func(...args), wait);
                    };
                };

                const inputs = [
                    this.markdownInput, this.typeInput, this.authorInput,
                    this.publisherNameInput, this.publisherUrlInput, this.baseUrlInput,
                    this.slugInput, this.dateInput, this.categoriesInput, this.descLengthInput
                ].filter(input => input !== null);

                inputs.forEach(input => {
                    if (input) {
                        input.addEventListener('input', debounce(() => this.updateTransformation(), 150));
                        input.addEventListener('change', () => this.updateTransformation());
                    }
                });

                if (this.markdownInput) {
                    this.markdownInput.addEventListener('input', () => this.updateCharCount());
                }
                if (this.copyButton) {
                    this.copyButton.addEventListener('click', () => this.copyToClipboard());
                }
                if (this.formatButton) {
                    this.formatButton.addEventListener('click', () => this.formatOutput());
                }
                if (this.loadSampleButton) {
                    this.loadSampleButton.addEventListener('click', () => this.loadSampleContent());
                }
                if (this.loadHowToSampleButton) {
                    this.loadHowToSampleButton.addEventListener('click', () => this.loadHowToSample());
                }
                if (this.loadTableSampleButton) {
                    this.loadTableSampleButton.addEventListener('click', () => this.loadTableSample());
                }
            }

            updateCharCount() {
                if (this.charCount && this.markdownInput && this.markdownInput.value !== undefined) {
                    this.charCount.textContent = this.markdownInput.value.length.toLocaleString();
                }
            }

            updateTransformation() {
                try {
                    const markdown = (this.markdownInput && this.markdownInput.value) ? this.markdownInput.value : "";
                    
                    if (!markdown.trim()) {
                        if (this.output) this.output.textContent = '// Enter markdown content to see JSON-LD output';
                        this.setStatus(this.outputStatus, 'success');
                        this.updateStats(0, 0, 0, 0);
                        this.clearUIFields();
                        return;
                    }

                    this.populateUIFromYAML(markdown);
                    const config = this.buildConfig();
                    const result = JsonLDTransformer.transform(markdown, config);
                    
                    const parser = new EnhancedMarkdownParser();
                    const annotations = parser.extractAnnotations(markdown);
                    const faqQuestions = parser.extractFaqQuestions(markdown);
                    const sections = parser.extractSections(markdown);
                    const tables = parser.extractTables(markdown);
                    const lists = parser.extractLists(markdown);
                    const links = parser.extractLinks(markdown);
                    const wordCount = this.countWords(markdown);
                    
                    this.updateStats(annotations.length, faqQuestions.length, result.length, wordCount);
                    
                    if (this.output) {
                        this.output.textContent = JSON.stringify(result, null, 2);
                        hljs.highlightElement(this.output);
                    }
                    
                    if (this.outputInfo) {
                        this.outputInfo.textContent = `Generated ${result.length} JSON-LD entities`;
                    }
                    this.setStatus(this.outputStatus, 'success');
                    this.setStatus(this.inputStatus, 'success');
                    
                } catch (error) {
                    if (this.output) {
                        this.output.textContent = `Error: ${error.message}\n\nStack trace:\n${error.stack}`;
                    }
                    if (this.outputInfo) {
                        this.outputInfo.textContent = 'Error occurred during transformation';
                    }
                    this.setStatus(this.outputStatus, 'error');
                    console.error('Transformation error:', error);
                }
            }

            clearUIFields() {
                if (this.authorInput && this.authorInput.value !== undefined) this.authorInput.value = "";
                if (this.publisherNameInput && this.publisherNameInput.value !== undefined) this.publisherNameInput.value = "";
                if (this.publisherUrlInput && this.publisherUrlInput.value !== undefined) this.publisherUrlInput.value = "";
                if (this.baseUrlInput && this.baseUrlInput.value !== undefined) this.baseUrlInput.value = "";
                if (this.slugInput && this.slugInput.value !== undefined) this.slugInput.value = "";
                if (this.categoriesInput && this.categoriesInput.value !== undefined) this.categoriesInput.value = "";
                if (this.typeInput && this.typeInput.value !== undefined) this.typeInput.value = "Article";
            }

            populateUIFromYAML(markdown) {
                const parser = new EnhancedMarkdownParser();
                const metadata = parser.extractMetadata(markdown);
                
                if (!metadata || Object.keys(metadata).length === 0) {
                    return;
                }

                if (this.typeInput && this.typeInput.value !== undefined && (!this.typeInput.value || this.typeInput.value === "Article")) {
                    this.typeInput.value = metadata.type || "Article";
                }
                
                if (this.authorInput && this.authorInput.value !== undefined && !this.authorInput.value.trim()) {
                    if (metadata.author && Array.isArray(metadata.author)) {
                        this.authorInput.value = metadata.author.join(', ');
                    }
                }
                
                if (this.publisherNameInput && this.publisherNameInput.value !== undefined && !this.publisherNameInput.value.trim()) {
                    if (metadata.publisher && metadata.publisher.name) {
                        this.publisherNameInput.value = metadata.publisher.name;
                    }
                }
                
                if (this.publisherUrlInput && this.publisherUrlInput.value !== undefined && !this.publisherUrlInput.value.trim()) {
                    if (metadata.publisher && metadata.publisher.url) {
                        this.publisherUrlInput.value = metadata.publisher.url;
                    }
                }
                
                if (this.baseUrlInput && this.baseUrlInput.value !== undefined && !this.baseUrlInput.value.trim()) {
                    if (metadata.base_url) {
                        this.baseUrlInput.value = metadata.base_url;
                    }
                }
                
                if (this.slugInput && this.slugInput.value !== undefined && !this.slugInput.value.trim()) {
                    if (metadata.slug) {
                        this.slugInput.value = metadata.slug;
                    }
                }
                
                if (this.dateInput && this.dateInput.value !== undefined && !this.dateInput.value) {
                    if (metadata.date) {
                        this.dateInput.value = metadata.date;
                    }
                }
                
                if (this.categoriesInput && this.categoriesInput.value !== undefined && !this.categoriesInput.value.trim()) {
                    if (metadata.categories && Array.isArray(metadata.categories)) {
                        this.categoriesInput.value = metadata.categories.join(', ');
                    }
                }
            }

            buildConfig() {
                const markdown = this.markdownInput && this.markdownInput.value ? this.markdownInput.value : "";
                const parser = new EnhancedMarkdownParser();
                const metadata = parser.extractMetadata(markdown);

                let authors;
                const uiAuthors = this.authorInput && this.authorInput.value
                    ? this.authorInput.value.split(',').map(a => a.trim()).filter(a => a)
                    : [];
                
                if (uiAuthors.length > 0) {
                    authors = uiAuthors;
                } else if (metadata.author && Array.isArray(metadata.author)) {
                    authors = metadata.author;
                } else {
                    authors = Config.DEFAULT_AUTHOR;
                }

                const publisherName = this.publisherNameInput && this.publisherNameInput.value
                    ? this.publisherNameInput.value
                    : (metadata.publisher && metadata.publisher.name) || Config.DEFAULT_PUBLISHER.name;
                
                const publisherUrl = this.publisherUrlInput && this.publisherUrlInput.value
                    ? this.publisherUrlInput.value
                    : (metadata.publisher && metadata.publisher.url) || Config.DEFAULT_PUBLISHER.url;

                const publisher = {
                    '@type': 'Organization',
                    name: publisherName,
                    url: publisherUrl,
                    '@id': (metadata.publisher && metadata.publisher.id) || publisherUrl
                };

                if (metadata.publisher && metadata.publisher.address) {
                    publisher.address = {
                        '@type': 'PostalAddress',
                        streetAddress: metadata.publisher.address.streetAddress || '',
                        addressLocality: metadata.publisher.address.addressLocality || '',
                        postalCode: metadata.publisher.address.postalCode || ''
                    };
                }
                if (metadata.publisher && metadata.publisher.telephone) {
                    publisher.telephone = metadata.publisher.telephone;
                }

                return new Config({
                    type: (this.typeInput && this.typeInput.value) || metadata.type || Config.DEFAULT_TYPE,
                    author: authors,
                    publisher: publisher,
                    baseUrl: (this.baseUrlInput && this.baseUrlInput.value) || metadata.base_url || Config.DEFAULT_BASE_URL,
                    date: (this.dateInput && this.dateInput.value) || metadata.date || Config.DEFAULT_DATE,
                    slug: (this.slugInput && this.slugInput.value) || metadata.slug || Config.DEFAULT_SLUG,
                    keywords: metadata.keywords || Config.DEFAULT_KEYWORDS,
                    categories: (this.categoriesInput && this.categoriesInput.value)
                        ? this.categoriesInput.value.split(',').map(c => c.trim()).filter(c => c)
                        : metadata.categories || Config.DEFAULT_CATEGORIES,
                    descriptionLength: parseInt(this.descLengthInput && this.descLengthInput.value) || Config.DEFAULT_DESCRIPTION_LENGTH
                });
            }

            updateStats(annotations, faqs, entities, words) {
                const parser = new EnhancedMarkdownParser();
                const markdownValue = (this.markdownInput && this.markdownInput.value) ? this.markdownInput.value : "";
                const sections = parser.extractSections(markdownValue);
                const tables = parser.extractTables(markdownValue);
                const lists = parser.extractLists(markdownValue);
                
                if (this.annotationCount) this.annotationCount.textContent = annotations;
                if (this.faqCount) this.faqCount.textContent = faqs;
                if (this.sectionCount) this.sectionCount.textContent = sections.length;
                if (this.entityCount) this.entityCount.textContent = entities;
                
                const tableCountElement = document.getElementById('tableCount');
                const listCountElement = document.getElementById('listCount');
                
                if (tableCountElement) tableCountElement.textContent = tables.length;
                if (listCountElement) listCountElement.textContent = lists.length;
            }

            countWords(text) {
                return text.trim().split(/\s+/).filter(word => word.length > 0).length;
            }

            setStatus(element, status) {
                if (element) {
                    element.className = `status-indicator status-${status}`;
                }
            }

            copyToClipboard() {
                if (this.output && this.output.textContent) {
                    navigator.clipboard.writeText(this.output.textContent)
                        .then(() => {
                            this.showNotification('JSON-LD copied to clipboard!', 'success');
                        })
                        .catch(() => {
                            this.showNotification('Failed to copy to clipboard', 'error');
                        });
                }
            }

            formatOutput() {
                try {
                    if (this.output && this.output.textContent) {
                        const parsed = JSON.parse(this.output.textContent);
                        this.output.textContent = JSON.stringify(parsed, null, 2);
                        hljs.highlightElement(this.output);
                    }
                } catch (error) {
                    this.showNotification('Invalid JSON format', 'error');
                }
            }

            showNotification(message, type) {
                const notification = document.createElement('div');
                notification.className = `fixed top-4 right-4 px-6 py-3 rounded-lg text-white z-50 fade-in ${
                    type === 'success' ? 'bg-green-500' : 'bg-red-500'
                }`;
                notification.textContent = message;
                document.body.appendChild(notification);

                setTimeout(() => {
                    notification.remove();
                }, 3000);
            }

            loadSampleContent() {
                const sampleMarkdown = `---
type: "Article"
schema: "https://schema.org"
base_url: "https://www.iunera.com/blog/"
date: "2025-06-01"
author:
  - Christian Schmitt
  - Dr. Tim Frey
publisher:
  name: Iunera
  url: "https://www.iunera.com/"
  id: "https://www.iunera.com"
  address:
    type: PostalAddress
    streetAddress: "Altrottstra√üe 31"
    addressLocality: Walldorf
    postalCode: "69190"
  telephone: "+49 6227 381350"
slug: license-token-fair-code
keywords:
  - open source
  - fair code
  - license token
  - blockchain
  - AI
categories:
  - Technology
  - Software Licensing
  - Blockchain Innovation
---

# License Token: Pioneering Fair Code and Combating Open Source Exploitation

At [Iunera](https://www.iunera.com/)@{Organization,name=Iunera,@id=#iunera}, we are revolutionizing open source software with the **License Token** model, specifically the [Open Compensation Token License (OCTL)](https://github.com/open-compensation-token-license/octl)@{CreativeWork,license=https://github.com/open-compensation-token-license/octl/blob/main/LICENSE.md,@id=#octl}. This article explores how OCTL tackles exploitation through innovative blockchain technology.

## Understanding the Problem

Traditional open source licenses fail to ensure fair compensation for developers. Key issues include:

- Lack of revenue mechanisms for creators
- Corporate exploitation without giving back
- Unsustainable development models
- No tracking of actual usage and value

## OCTL License Comparison

| License Type | Revenue Model | Usage Tracking | Fair Compensation |
|--------------|---------------|----------------|-------------------|
| MIT/GPL      | None          | No             | No                |
| Commercial   | Fixed Fee     | Limited        | Partial           |
| OCTL         | NFT Royalties | Blockchain     | Yes               |

## Implementation Benefits

The OCTL solution provides several advantages:

1. **Automated royalty distribution** through smart contracts
2. **Transparent usage tracking** via blockchain technology  
3. **Sustainable developer income** from ongoing usage
4. **Community-driven governance** for license parameters

Visit the [OCTL GitHub repository](https://github.com/open-compensation-token-license/octl) for detailed implementation guides and source code access.

## Frequently Asked Questions

### What is OCTL?
A blockchain-based license ensuring fair compensation via NFT royalties and smart contract automation.

### How does OCTL prevent exploitation?
NFTs and smart contracts track usage, requiring automatic royalty payments to developers based on actual usage metrics.

### Which blockchains are supported?
Currently supports Ethereum, Polygon, and other EVM-compatible networks with plans for multi-chain expansion.

--- end of article`;

                this.clearUIFields();
                if (this.markdownInput && this.markdownInput.value !== undefined) {
                    this.markdownInput.value = sampleMarkdown;
                }
                this.updateCharCount();
                this.updateTransformation();
            }

            loadHowToSample() {
                const howToMarkdown = `---
type: "HowTo"
schema: "https://schema.org"
base_url: "https://www.iunera.com/guides/"
date: "2025-06-01"
author:
  - Technical Team
publisher:
  name: Iunera
  url: "https://www.iunera.com/"
  id: "https://www.iunera.com"
slug: how-to-implement-octl
keywords:
  - implementation
  - license
  - blockchain
  - tutorial
categories:
  - Tutorial
  - Implementation
  - Blockchain
---

# How to Implement OCTL in Your Project

Learn how to integrate the Open Compensation Token License into your software project for fair compensation.

## Prerequisites

Before starting, ensure you have the following requirements:

- Node.js version 16 or higher
- Access to an Ethereum-compatible blockchain
- Basic understanding of smart contracts
- Git for version control

## Supported Networks

| Network | Chain ID | Gas Cost | Recommended |
|---------|----------|----------|-------------|
| Ethereum | 1 | High | Production |
| Polygon | 137 | Low | Development |
| Arbitrum | 42161 | Medium | Scaling |

## Prepare Your Environment

First, set up your development environment with the necessary tools and dependencies.

1. Install Node.js and npm
2. Clone the OCTL repository
3. Install project dependencies
4. Configure environment variables

## Configure the License

Download the OCTL template and customize it with your project details:

- Set royalty percentages (recommended 2-5%)
- Configure payment addresses
- Define usage tracking parameters
- Specify license terms and conditions

## Deploy Smart Contracts

Use the provided deployment scripts to publish your license smart contracts:

1. **Compile contracts** using Hardhat or Truffle
2. **Test locally** on development network
3. **Deploy to testnet** for integration testing
4. **Deploy to mainnet** for production use

## Verify Implementation

Test your OCTL integration with these verification steps:

- Run automated test suite
- Check royalty distribution functionality
- Verify usage tracking accuracy
- Test license compliance monitoring

## Frequently Asked Questions

### How long does implementation take?
Typically 2-4 hours for a standard project setup with existing blockchain infrastructure.

### Which blockchains are supported?
Ethereum, Polygon, Arbitrum, and other EVM-compatible networks are fully supported.

### What are the gas costs?
Deployment costs vary by network. Check current rates on blockchain explorer websites like [Etherscan](https://etherscan.io/) for Ethereum or [Polygonscan](https://polygonscan.com/) for Polygon.

--- end of article`;

                this.clearUIFields();
                if (this.markdownInput && this.markdownInput.value !== undefined) {
                    this.markdownInput.value = howToMarkdown;
                }
                this.updateCharCount();
                this.updateTransformation();
            }

            loadTableSample() {
                const tableMarkdown = `---
type: "Article"
schema: "https://schema.org"
base_url: "https://www.iunera.com/blog/"
date: "2025-06-01"
author:
  - Data Team
publisher:
  name: Iunera
  url: "https://www.iunera.com/"
  id: "https://www.iunera.com"
slug: comprehensive-table-examples
keywords:
  - tables
  - data
  - comparison
  - pricing
categories:
  - Data Analysis
  - Technology Comparison
---

# Comprehensive Table Examples for Schema.org Mapping

This article demonstrates various table types and how they map to schema.org structured data.

## Cloud Service Pricing Comparison

| Plan | Price | Storage | Users | Support |
|------|-------|---------|-------|---------|
| Basic | $10/month | 10GB | 5 | Email |
| Pro | $25/month | 100GB | 25 | Priority |
| Enterprise | $100/month | 1TB | Unlimited | 24/7 Phone |

## Product Specifications

| Property | Value | Unit | Range |
|----------|-------|------|-------|
| Weight | 2.5 | kg | 2.0-3.0 |
| Dimensions | 30x20x5 | cm | Standard |
| Battery Life | 12 | hours | 10-14 |
| Operating Temperature | -10 to 50 | ¬∞C | Extended |

## Network Performance Dataset

| Region | Latency | Bandwidth | Uptime | Users |
|--------|---------|-----------|--------|-------|
| US-East | 15ms | 1000Mbps | 99.9% | 150000 |
| EU-West | 22ms | 800Mbps | 99.8% | 95000 |
| Asia-Pacific | 35ms | 600Mbps | 99.7% | 75000 |
| South America | 45ms | 400Mbps | 99.5% | 25000 |

## Company Directory

| Company | Website | Industry | Founded | Employees |
|---------|---------|----------|---------|-----------|
| GitHub | https://github.com | Software Development | 2008 | 2000+ |
| Microsoft | https://microsoft.com | Technology | 1975 | 220000+ |
| Google | https://google.com | Technology | 1998 | 140000+ |

## Feature Comparison Matrix

| Feature | Basic Plan | Pro Plan | Enterprise |
|---------|------------|----------|------------|
| API Access | Limited | Full | Full |
| Custom Domains | ‚úó | ‚úì | ‚úì |
| SSL Certificates | ‚úó | ‚úó | ‚úì |
| 24/7 Support | ‚úó | ‚úì | ‚úì |
| SLA Guarantee | ‚úó | 99% | 99.9% |

Each table type will be automatically detected and mapped to appropriate schema.org types with semantic properties.

--- end of article`;

                this.clearUIFields();
                if (this.markdownInput && this.markdownInput.value !== undefined) {
                    this.markdownInput.value = tableMarkdown;
                }
                this.updateCharCount();
                this.updateTransformation();
            }
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', () => {
            new UIController();
        });
    </script>
</body>
</html>
